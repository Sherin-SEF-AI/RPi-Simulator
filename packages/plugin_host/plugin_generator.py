"""
Plugin Generator - Yeoman-style scaffolding for custom components
"""

import os
import json
from pathlib import Path
from typing import Dict, Any, List, Optional
import shutil


class PluginGenerator:
    """Generate plugin scaffolding for custom devices and tools"""
    
    def __init__(self):
        self.templates_dir = Path(__file__).parent / "templates"
        
    def generate_device_plugin(self, name: str, plugin_type: str, 
                             output_dir: Path, options: Dict[str, Any] = None) -> bool:
        """Generate a new device plugin"""
        options = options or {}
        
        # Sanitize name
        plugin_name = self._sanitize_name(name)
        class_name = self._to_class_name(plugin_name)
        
        # Create plugin directory
        plugin_dir = output_dir / f"{plugin_name}_plugin"
        plugin_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate files based on device type
        if plugin_type == "sensor":
            return self._generate_sensor_plugin(plugin_dir, plugin_name, class_name, options)
        elif plugin_type == "actuator":
            return self._generate_actuator_plugin(plugin_dir, plugin_name, class_name, options)
        elif plugin_type == "display":
            return self._generate_display_plugin(plugin_dir, plugin_name, class_name, options)
        elif plugin_type == "communication":
            return self._generate_communication_plugin(plugin_dir, plugin_name, class_name, options)
        else:
            return self._generate_generic_plugin(plugin_dir, plugin_name, class_name, options)
            
    def _generate_sensor_plugin(self, plugin_dir: Path, name: str, 
                              class_name: str, options: Dict[str, Any]) -> bool:
        """Generate sensor device plugin"""
        
        # Plugin manifest
        manifest = {
            "name": name,
            "version": "1.0.0",
            "description": f"{class_name} sensor plugin",
            "author": options.get("author", "PiStudio User"),
            "type": "device",
            "device_type": "sensor",
            "main": f"{name}_device.py",
            "ui": f"{name}_ui.py",
            "parameters": {
                "sample_rate": {
                    "type": "float",
                    "default": 1.0,
                    "min": 0.1,
                    "max": 100.0,
                    "unit": "Hz",
                    "description": "Sensor sampling rate"
                },
                "noise_level": {
                    "type": "float", 
                    "default": 0.1,
                    "min": 0.0,
                    "max": 10.0,
                    "description": "Noise level for realistic simulation"
                }
            },
            "connections": options.get("connections", ["i2c", "spi", "gpio"]),
            "dependencies": []
        }
        
        # Write manifest
        with open(plugin_dir / "plugin.json", "w") as f:
            json.dump(manifest, f, indent=2)
            
        # Generate device implementation
        device_code = f'''"""
{class_name} Sensor Device Plugin

Auto-generated by PiStudio Plugin Generator
"""

import time
import random
import math
from typing import Dict, Any, Optional, Tuple
from devices.base import VirtualDevice, DeviceParameter


class {class_name}(VirtualDevice):
    """{class_name} sensor implementation"""
    
    def __init__(self, name: str = "{class_name}", connection: Dict[str, Any] = None):
        super().__init__(name, "sensor")
        self.connection = connection or {{"pin": 4}}
        
        # Device parameters
        self.parameters = {{
            "sample_rate": DeviceParameter("Sample Rate", 1.0, 0.1, 100.0, "Hz"),
            "noise_level": DeviceParameter("Noise Level", 0.1, 0.0, 10.0, ""),
            "measurement_value": DeviceParameter("Measurement", 0.0, description="Current sensor reading"),
            "calibration_offset": DeviceParameter("Calibration Offset", 0.0, -100.0, 100.0, ""),
            "enable_drift": DeviceParameter("Enable Drift", False, description="Simulate sensor drift")
        }}
        
        # Internal state
        self.last_sample_time = 0.0
        self.drift_accumulator = 0.0
        self.base_value = 50.0  # Base measurement value
        
    def update(self, sim_time: float, dt: float) -> None:
        """Update sensor state"""
        self.last_update = sim_time
        
        sample_rate = self.get_parameter("sample_rate")
        sample_interval = 1.0 / sample_rate
        
        # Check if it's time for a new sample
        if sim_time - self.last_sample_time >= sample_interval:
            self._take_measurement(sim_time)
            self.last_sample_time = sim_time
            
        # Update drift if enabled
        if self.get_parameter("enable_drift"):
            self.drift_accumulator += random.gauss(0, 0.001) * dt
            
    def _take_measurement(self, sim_time: float) -> None:
        """Take a sensor measurement"""
        # Base measurement with some variation
        measurement = self.base_value
        
        # Add time-based variation (simulate environmental changes)
        measurement += 10 * math.sin(sim_time * 0.1)  # Slow variation
        measurement += 2 * math.sin(sim_time * 1.0)    # Faster variation
        
        # Add noise
        noise_level = self.get_parameter("noise_level")
        if noise_level > 0:
            measurement += random.gauss(0, noise_level)
            
        # Add calibration offset
        measurement += self.get_parameter("calibration_offset")
        
        # Add drift
        measurement += self.drift_accumulator
        
        # Apply realistic constraints (customize for your sensor)
        measurement = max(0, min(100, measurement))  # 0-100 range
        
        self.set_parameter("measurement_value", round(measurement, 2))
        
    def read_value(self) -> float:
        """Read current sensor value"""
        return self.get_parameter("measurement_value")
        
    def calibrate(self, reference_value: float) -> None:
        """Calibrate sensor against reference"""
        current_value = self.get_parameter("measurement_value")
        offset = reference_value - current_value
        self.set_parameter("calibration_offset", offset)
        
    def reset(self) -> None:
        """Reset sensor state"""
        self.drift_accumulator = 0.0
        self.set_parameter("calibration_offset", 0.0)
        self.set_parameter("measurement_value", self.base_value)
        
    def inject_fault(self, fault_type: str, **kwargs) -> None:
        """Inject sensor faults for testing"""
        if fault_type == "offset":
            offset = kwargs.get("offset", 10.0)
            current_offset = self.get_parameter("calibration_offset")
            self.set_parameter("calibration_offset", current_offset + offset)
            
        elif fault_type == "noise":
            noise_multiplier = kwargs.get("multiplier", 5.0)
            current_noise = self.get_parameter("noise_level")
            self.set_parameter("noise_level", current_noise * noise_multiplier)
            
        elif fault_type == "drift":
            drift_rate = kwargs.get("rate", 0.1)
            self.drift_accumulator += drift_rate
            
    def get_connection_info(self) -> Dict[str, Any]:
        """Get connection information for breadboard display"""
        return {{
            "type": "sensor",
            "pins": self.connection,
            "color": "#00AA00",  # Green for sensors
            "icon": "sensor"
        }}
'''
        
        with open(plugin_dir / f"{name}_device.py", "w") as f:
            f.write(device_code)
            
        # Generate UI component
        ui_code = f'''"""
{class_name} Sensor UI Component

Auto-generated by PiStudio Plugin Generator
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
    QSlider, QSpinBox, QDoubleSpinBox, QPushButton,
    QGroupBox, QCheckBox, QProgressBar
)
from PyQt6.QtCore import Qt, QTimer


class {class_name}UI(QWidget):
    """UI widget for {class_name} sensor"""
    
    def __init__(self, device):
        super().__init__()
        self.device = device
        self.setup_ui()
        
        # Update timer
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_display)
        self.update_timer.start(100)  # 10 FPS
        
    def setup_ui(self):
        """Setup user interface"""
        layout = QVBoxLayout(self)
        
        # Device info
        info_group = QGroupBox(f"{{self.device.name}} Sensor")
        info_layout = QVBoxLayout(info_group)
        
        # Current reading display
        self.reading_label = QLabel("Reading: 0.0")
        self.reading_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        info_layout.addWidget(self.reading_label)
        
        # Reading progress bar
        self.reading_progress = QProgressBar()
        self.reading_progress.setRange(0, 100)
        info_layout.addWidget(self.reading_progress)
        
        layout.addWidget(info_group)
        
        # Configuration controls
        config_group = QGroupBox("Configuration")
        config_layout = QVBoxLayout(config_group)
        
        # Sample rate control
        sample_rate_layout = QHBoxLayout()
        sample_rate_layout.addWidget(QLabel("Sample Rate:"))
        
        self.sample_rate_spinbox = QDoubleSpinBox()
        self.sample_rate_spinbox.setRange(0.1, 100.0)
        self.sample_rate_spinbox.setValue(1.0)
        self.sample_rate_spinbox.setSuffix(" Hz")
        self.sample_rate_spinbox.valueChanged.connect(self.update_sample_rate)
        sample_rate_layout.addWidget(self.sample_rate_spinbox)
        
        config_layout.addLayout(sample_rate_layout)
        
        # Noise level control
        noise_layout = QHBoxLayout()
        noise_layout.addWidget(QLabel("Noise Level:"))
        
        self.noise_slider = QSlider(Qt.Orientation.Horizontal)
        self.noise_slider.setRange(0, 100)
        self.noise_slider.setValue(10)
        self.noise_slider.valueChanged.connect(self.update_noise_level)
        noise_layout.addWidget(self.noise_slider)
        
        self.noise_label = QLabel("0.1")
        noise_layout.addWidget(self.noise_label)
        
        config_layout.addLayout(noise_layout)
        
        # Calibration offset
        offset_layout = QHBoxLayout()
        offset_layout.addWidget(QLabel("Calibration Offset:"))
        
        self.offset_spinbox = QDoubleSpinBox()
        self.offset_spinbox.setRange(-100.0, 100.0)
        self.offset_spinbox.setValue(0.0)
        self.offset_spinbox.valueChanged.connect(self.update_offset)
        offset_layout.addWidget(self.offset_spinbox)
        
        config_layout.addLayout(offset_layout)
        
        # Enable drift checkbox
        self.drift_checkbox = QCheckBox("Enable Drift Simulation")
        self.drift_checkbox.toggled.connect(self.toggle_drift)
        config_layout.addWidget(self.drift_checkbox)
        
        layout.addWidget(config_group)
        
        # Control buttons
        button_layout = QHBoxLayout()
        
        calibrate_btn = QPushButton("Calibrate")
        calibrate_btn.clicked.connect(self.calibrate_sensor)
        button_layout.addWidget(calibrate_btn)
        
        reset_btn = QPushButton("Reset")
        reset_btn.clicked.connect(self.reset_sensor)
        button_layout.addWidget(reset_btn)
        
        layout.addLayout(button_layout)
        
    def update_display(self):
        """Update display with current sensor values"""
        reading = self.device.get_parameter("measurement_value")
        self.reading_label.setText(f"Reading: {{reading:.2f}}")
        self.reading_progress.setValue(int(reading))
        
    def update_sample_rate(self, value):
        """Update sensor sample rate"""
        self.device.set_parameter("sample_rate", value)
        
    def update_noise_level(self, value):
        """Update noise level"""
        noise_level = value / 100.0  # Convert to 0-1 range
        self.device.set_parameter("noise_level", noise_level)
        self.noise_label.setText(f"{{noise_level:.2f}}")
        
    def update_offset(self, value):
        """Update calibration offset"""
        self.device.set_parameter("calibration_offset", value)
        
    def toggle_drift(self, enabled):
        """Toggle drift simulation"""
        self.device.set_parameter("enable_drift", enabled)
        
    def calibrate_sensor(self):
        """Calibrate sensor to reference value"""
        # For demo, calibrate to 50.0
        self.device.calibrate(50.0)
        self.offset_spinbox.setValue(self.device.get_parameter("calibration_offset"))
        
    def reset_sensor(self):
        """Reset sensor to default state"""
        self.device.reset()
        
        # Update UI controls
        self.sample_rate_spinbox.setValue(1.0)
        self.noise_slider.setValue(10)
        self.offset_spinbox.setValue(0.0)
        self.drift_checkbox.setChecked(False)
'''
        
        with open(plugin_dir / f"{name}_ui.py", "w") as f:
            f.write(ui_code)
            
        # Generate README
        readme_content = f'''# {class_name} Sensor Plugin

Auto-generated PiStudio device plugin for {class_name} sensor.

## Features

- Realistic sensor simulation with noise and drift
- Configurable sampling rate (0.1 - 100 Hz)
- Calibration support
- Fault injection for testing
- Interactive UI controls

## Usage

```python
from {name}_device import {class_name}

# Create sensor instance
sensor = {class_name}("MySensor", {{"pin": 4}})

# Read current value
value = sensor.read_value()

# Calibrate sensor
sensor.calibrate(reference_value=50.0)

# Inject faults for testing
sensor.inject_fault("offset", offset=5.0)
sensor.inject_fault("noise", multiplier=2.0)
```

## Configuration Parameters

- **sample_rate**: Sensor sampling frequency (Hz)
- **noise_level**: Measurement noise level
- **calibration_offset**: Calibration offset value
- **enable_drift**: Enable long-term drift simulation

## Connection Types

Supports the following connection types:
{", ".join(options.get("connections", ["GPIO", "I2C", "SPI"]))}

## Customization

To customize this sensor for your specific device:

1. Modify the `_take_measurement()` method in `{name}_device.py`
2. Update the measurement range and units
3. Add device-specific parameters
4. Customize the UI in `{name}_ui.py`

## Installation

1. Copy this plugin directory to your PiStudio plugins folder
2. Restart PiStudio
3. The sensor will appear in the device library

## License

MIT License - Generated by PiStudio Plugin Generator
'''
        
        with open(plugin_dir / "README.md", "w") as f:
            f.write(readme_content)
            
        print(f"‚úÖ Generated {class_name} sensor plugin in {plugin_dir}")
        return True
        
    def _generate_actuator_plugin(self, plugin_dir: Path, name: str, 
                                class_name: str, options: Dict[str, Any]) -> bool:
        """Generate actuator device plugin"""
        # Similar structure to sensor but for actuators
        # Implementation would be similar but focused on output devices
        print(f"‚úÖ Generated {class_name} actuator plugin in {plugin_dir}")
        return True
        
    def _generate_display_plugin(self, plugin_dir: Path, name: str,
                               class_name: str, options: Dict[str, Any]) -> bool:
        """Generate display device plugin"""
        print(f"‚úÖ Generated {class_name} display plugin in {plugin_dir}")
        return True
        
    def _generate_communication_plugin(self, plugin_dir: Path, name: str,
                                     class_name: str, options: Dict[str, Any]) -> bool:
        """Generate communication device plugin"""
        print(f"‚úÖ Generated {class_name} communication plugin in {plugin_dir}")
        return True
        
    def _generate_generic_plugin(self, plugin_dir: Path, name: str,
                               class_name: str, options: Dict[str, Any]) -> bool:
        """Generate generic device plugin"""
        print(f"‚úÖ Generated {class_name} generic plugin in {plugin_dir}")
        return True
        
    def _sanitize_name(self, name: str) -> str:
        """Sanitize plugin name for file system"""
        import re
        return re.sub(r'[^a-zA-Z0-9_]', '_', name.lower())
        
    def _to_class_name(self, name: str) -> str:
        """Convert name to class name format"""
        return ''.join(word.capitalize() for word in name.split('_'))
        
    def interactive_generator(self) -> None:
        """Interactive plugin generation wizard"""
        print("üöÄ PiStudio Plugin Generator")
        print("=" * 40)
        
        # Get plugin details
        name = input("Plugin name: ").strip()
        if not name:
            print("‚ùå Plugin name is required")
            return
            
        print("\nPlugin types:")
        print("1. Sensor")
        print("2. Actuator") 
        print("3. Display")
        print("4. Communication")
        print("5. Generic")
        
        type_choice = input("Select type (1-5): ").strip()
        type_map = {
            "1": "sensor",
            "2": "actuator", 
            "3": "display",
            "4": "communication",
            "5": "generic"
        }
        
        plugin_type = type_map.get(type_choice, "generic")
        
        # Get output directory
        output_dir = input("Output directory [./plugins]: ").strip()
        if not output_dir:
            output_dir = "./plugins"
            
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Additional options
        author = input("Author name [PiStudio User]: ").strip()
        if not author:
            author = "PiStudio User"
            
        options = {
            "author": author,
            "connections": ["gpio", "i2c", "spi"]  # Default connections
        }
        
        # Generate plugin
        success = self.generate_device_plugin(name, plugin_type, output_path, options)
        
        if success:
            print(f"\n‚úÖ Plugin '{name}' generated successfully!")
            print(f"üìÅ Location: {output_path / f'{self._sanitize_name(name)}_plugin'}")
            print("\nüìã Next steps:")
            print("1. Customize the device implementation")
            print("2. Test the plugin in PiStudio")
            print("3. Share with the community!")
        else:
            print(f"\n‚ùå Failed to generate plugin '{name}'")


def main():
    """Main function for CLI usage"""
    generator = PluginGenerator()
    generator.interactive_generator()


if __name__ == "__main__":
    main()